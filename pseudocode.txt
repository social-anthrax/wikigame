https://www.sqa.org.uk/sqa/files_ccc/Reference-language-for-Computing-Science-Sep2016.pdf

CLASS Noodlemap()
    PUBLIC METHOD Noodlemap() #constructor method
        INITIALISE PRIVATE DICTIONARY edges 
        INITIALISE PRIVATE ARRAY OF ARRAY OF STRING matrix INITIALLY [[""]]
    END METHOD

    PRIVATE METHOD addEdge(origin_noodle, destination_noodle)
        APPEND destination_noodle TO edges[origin_noodle]
        
    END METHOD

    PRIVATE METHOD loadDatabase(tableName as string)
        
        INITIALISE domain AS STRING 
        connect to database "websites"
        
        domain = format tablename to domain form
        execute "SELECT OriginURL, Hyperlink FROM parameter" where parameter = domain and store result in 2d array called result
        

        INITIALISE cols_count AS INTEGER = 2
        INITIALISE rows_count AS INTEGER = len(result)
        
        
        ME.matrix = [["" for x = 0 to cols+count-1] for y = 0 to rows_count -1]

        INITIALISE innerLoop AS INTEGER = 0
        INITIALISE outerLoop as INTEGER = 0
        

        FOR EACH row IN result DO
            SET innerLoop = 0
            FOR each value in row DO
                SET ME.Matrix[outerloop][innerloop] = value  #as y value is before the x value
                SET innerLoop = innerLoop + 1
            END FOR
            SET outerLoop = outerLoop + 1

        END FOR

        FOR index = 0 to rows_count - 1 DO
            Me.addEdge(ME.matrix[index][0], ME.addEdge[index][1])
        END FOR 

        CLOSE CONNECTION
    END METHOD

    PUBLIC METHOD dijkstra(initial, final_destination)
        INITIALISE shortest_paths AS DICTIONARY 
        INITIALISE current_noodle AS STRING = initial
        INITIALISE visited AS DEFAULT SET #this is being done as it has a method to check if it contains things
        

        WHILE current_noodle NOT = final_destination DO
            ADD current_noodle TO visited SET
            INITIALISE destinations AS ARRAY INITIALLY ME.edges[current_noodle]

            FOR EACH next_noodles IN destinations DO
                IF next_noodles is not in shortest_paths
                    SET shortest_paths[next_noodles] = (current_noodle, 1) 
                ELSE
                    INITIALISE current_shortest_weight AS STRING
                    SET current_shortest_weight = shortest_paths[next_noodles][1]
                    IF current_shortest_weight > 1:
                        SET shortest_paths[next_noodles] = (current_noodle,1)
                    END IF
                END IF
            END FOR

            INITIALISE possible_noodle AS DEFAULT DICTIONARY
            FOR EACH noodle in shortest_paths
                IF noodle not in visited
                    SET possible_noodle[noodle] = shortest_paths[noodle]
                END IF
            END FOR

            IF possible_noodle is empty
                SEND message that there is no path TO DISPLAY
            END IF
            SET current_noodle = smallest value between possible_noodle and all the values at index one of all keys in the 
        END WHILE

        INITIALISE path AS ARRAY OF DICTIONARY
        WHILE current_noodle has values in it
            APPEND current_noodle TO path
            SET next_noodles = shortest_paths[current_noodle][0]
            SET current_noodle = next_noodles
        END WHILE

        SET path = reverse path
        RETURN path

    END METHOD

    PUBLIC METHOD returnMap(sort INITIALLY TRUE)
        INITIALISE unsorted_list[] AS ARRAY
        SET unsorted_list = ARRAY of keys of ME.edges
        
        IF sort = TRUE
            INITIALISE sorted_list AS DEFAULT DICTIONARY
            FOR EACH key IN ME.mergeSort(unsorted_list):
                SET sorted_list[key] = ME.edges[key]
            END FOR
            RETURN sorted_list
        ELSE:
            RETURN ME.edges
        END IF

    END METHOD

    PRIVATE METHOD mergeSort(array) 
        IF length of array <= 1
            RETURN array
        END IF

        INITIALISE left AS ARRAY OF STRING
        INITIALISE right AS ARRAY OF STRING
        INITIALISE counter AS INTEGER INITIALLY 0

        FOR EACH value IN array
            IF counter < (length of array) / 2 rounded down
                APPEND value TO left
            ELSE:
                APPEND value TO right
            END IF
            SET counter = counter + 1
        END FOR

        SET left = ME.mergeSort(left)
        SET right = ME.mergeSort(right)

        return self.Merge(left,right)
    END METHOD

    PRIVATE METHOD Merge(left, right)
        INITIALISE result AS ARRAY

        WHILE length of left NOT = 0 AND length of right NOT = 0
            FOR letter = 0 to (smallest between length of left[0] and length of right[0])
                IF left[0][letter] comes before right[0][letter]
                    pop left[0] and append it to result
                
                ELSE IF right[0][letter] comes before left[0][letter]
                    pop right[0] and append it to result
                
                ELSE IF length of left[0] < length of right[0] and (smallest between length of left[0] and length of right[0]) - 1
                    pop left[0] and append it to result
                
                ELSE IF length of left[0] > length of right[0] and (smallest between length of left[0] and length of right[0]) - 1
                    pop right[0] and append it to result

                END IF    
            END FOR
        END WHILE

        WHILE length of left NOT = 0
            pop left[0] and append it to result
        END WHILE

        WHILE length of right NOT = 0
            pop right[0] and append it to result
        END WHILE
    END METHOD

    PRIVATE METHOD insertSort(unsorted_list):
        FOR start_value = 1 to lenght of unsorted_list
            FOR current_value = start_value to 0 STEP -1
                FOR letter = 0 to smallest between length of unsorted_list[current_value] and length of unsorted_list[current_value-1]
                    IF unsorted_list[current_value][letter] comes before unsorted_list[current_noodle][letter]
                        SWAP unsorted_list[current_value] and unsorted_list[current_value-1]
                        BREAK FOR LOOP
                    ELSE IF length of unsorted_list[current_value] < length of unsorted_list[current_value - 1] and unsorted_list[current_value][letter] = unsorted_list[current_value][letter] AND letter = smallest value between length of unsorted_list[current_value] and length of unsorted_list[current_value]
                        SWAP unsorted_list[current_value] and unsorted_list[current_value-1]
                    END IF
                END FOR
            END FOR
        END FOR
        RETURN unsorted_list
    END METHOD
END CLASS


CLASS UI()
    INITIALISE PUBLIC STRING sectionName
    INITIALISE PRIVATE STRING contents
    INITIALISE PRIVATE STRING prompt
    INITIALISE PRIVATE DICTIONARY commands

    METHOD UI(section) #this is the constructor
        SET ME.sectionName = section
    END METHOD

    REGION setters
        METHOD setContents(contentsText)
            SET ME.contents = contentsText
        END METHOD

        METHOD setCommands(prompt, kwargs AS DICTIONARY)
            ME.prompt = prompt
            FOR EACH key, value IN kwargs
                SET ME.commands[key.PREDEFINEDFUNCTION.lower()] = value
            END FOR
        END METHOD
    END REGION

    REGION getters
        METHOD showUi(acceptCommands AS BOOLEAN DEFAULT TRUE)
            CLEARSCREEN()
            INITIALISE userInput AS STRING
            SEND ME.contents TO DISPLAY
            IF acceptCommands = TRUE
                RECIEVE userInput FROM KEYBOARD
                IF userInput IS IN ME.commands
                    CALL ME.commands[userInput.lower()]() #calls the function with the name at the key of the command dictionary
                ELSE 
                    SEND "Please select a valid option." TO DISPLAY
                    WAIT FOR KEY 
                    CALL ME.showUI()
                END IF
            END IF
        END METHOD 


    END REGION
END CLASS

PROCEDURE pathfinder()
    INITIALISE start AS STRING
    INITIALISE end AS STRING
    INITIALISE domain AS STRING

    RECIEVE start FROM KEYBOARD
    RECIEVE end FROM KEYBOARD

    IF first character of RECIEVE userInput FROM KEYBOARD = "y"
        CALL scraper.runScrape(start)
    END IF

    domain =  format start into domain form
    CALL noodles.loadDatabase(domain)
    SEND noodles.dijkstra(start, end) TO DISPLAY
END PROCEDURE

PROCEDURE clearDatabases()
    mydb = connect to database
    execute "SHOW TABLES" and store results in array called result
    FOR EACH table IN result
        SEND table TO DISPLAY
    END FOR
    GET userCheck FROM KEYBOARD
    IF first character of userCheck = "y"
        FOR EACH table IN result
            SEND "Deleting " + table + "..." TO DISPLAY
            exectute "Drop table if exists parameter" where parameter is table 
            SEND table + " deleted"
        END FOR
        SEND "All cached Databases deleted." TO DISPLAY
    ELSE
        mainMenu.showUI()

    END IF
    CLOSE CONNECTION
END PROCEDURE

PROCEDURE sort()
    SEND "please enter the start page" TO DISPLAY
    RECIEVE start FROM KEYBOARD 
    SEND "Would you like to reindex the database? (y/n)" TO DISPLAY
    if RECIEVE userInput from user = "y":
        CALL scraper.runScrape(start)

    SET domain = format start into domain form
    SEND "Loading database..." TO DISPLAY
    
    CALL noodles.loadDatabase(domain)
    SEND "Database loaded." TO DISPLAY
    SET validInput = False
    WHILE validInput = False
        SEND ""Do you wish to write output to file? (y/n)" TO DISPLAY
        GET write_to_file FROM KEYBOARD
        IF write_to_file = "y":
            SET validInput = True
            SEND "Please input the name of the file you wish to write output to" TO DISPLAY
            GET writeFileName FROM KEYBOARD
            SET openedFile = open writeFileName in write mode
            SEND "Sorting and writing to file." TO DISPLAY
            IF last 4 characters of writeFileName = ".csv"
                FOR EACH key AND array in noodles.returnMap()  
                    CALL openedFile.write(key)
                    FOR value IN array
                        write to openedFile ", " + value
                    END FOR
                    write to openedFile("\n")
                    SEND key + ": " array TO DISPLAY
            ELSE:
                FOR EACH key AND array IN noodles.returnMap()
                    write to openedFile key + ": " + array" + newline 
                    SEND key + ": " + array" TO DISPLAY
                END FOR
            END IF
        ELSE IF write_to_file = "n"
            SET validInput = True
            SEND "Sorting and printing to terminal." TO DISPLAY
            FOR EACH key AND array in noodles.returnMap()
            SEND key + ": " + array"
        ELSE:
            SEND "Please enter valid input." TO DISPLAY
        END IF
    SEND "Complete" TO DISPLAY 
END PROCEDURE
    
    TODO: THIS




#on program start 
checking if program is running from command line arguments or not:

IF length of arguments passed in command line > 1 
    IF mode argument is passed as "pathfinder"
        INITIALISE domain AS STRING
        SET domain = format startPage argument to domain form

        IF reindex argument = TRUE 
            run the web scraper with parameters
            CALL noodles.loadDatabase(domain)
            
            
        END IF
        
        SEND noodles.dijkstra(startPage argument, endPage argument) TO DISPLAY

    ELSE IF mode argument = "returnmap"
        IF reindex argument = TRUE 
            run the web scraper with parameters
            CALL noodles.loadDatabase(domain)

        END IF

        CALL noodles.loadDatabase(startPage argument)
        FOR EACH key and value IN noodles.returnMap()
            SEND key + ": " + value TO DISPLAY
        END FOR
    ELSE
        SEND "Command not recognised" TO DISPLAY
        QUIT PROGRAM
    END IF

ELSE
    INSTANCIATE noodles as new Noodlemap object
    INSTANCIATE mainMenu as new UI("mainMenu") object
    CALL mainMenu.setContents('Welcome to PathFinder! To see help, type: help \n Options: \n pathfinder: Finds a path between two URLs \n ReturnMap: View all found links.')
    CALL mainMenu.setCommands(Pick option', pathfinder() procedure, returnMap() procedure, help() procedure, quit() procedure)
    CALL mainMenu.showUI()

END IF