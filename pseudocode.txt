https://www.sqa.org.uk/sqa/files_ccc/Reference-language-for-Computing-Science-Sep2016.pdf

CLASS noodlemap()
    PUBLIC METHOD noodlemap() #constructor method
        INITIALISE PRIVATE DICTIONARY edges 
        INITIALISE PRIVATE ARRAY OF ARRAY OF STRING matrix INITIALLY [[""]]
    END METHOD

    PRIVATE METHOD addEdge(origin_noodle, destination_noodle)
        APPEND destination_noodle TO edges[origin_noodle]
        
    END METHOD

    PRIVATE METHOD loadDatabase(tableName as string)
        
        INITIALISE domain AS STRING 
        connect to database "websites"
        
        domain = format tablename to domain form
        execute "SELECT OriginURL, Hyperlink FROM parameter" where parameter = domain and store result in 2d array called result
        

        INITIALISE cols_count AS INTEGER = 2
        INITIALISE rows_count AS INTEGER = len(result)
        
        
        ME.matrix = [["" for x = 0 to cols+count-1] for y = 0 to rows_count -1]

        INITIALISE innerLoop AS INTEGER = 0
        INITIALISE outerLoop as INTEGER = 0
        

        FOR EACH row IN result DO
            SET innerLoop = 0
            FOR each value in row DO
                SET ME.Matrix[outerloop][innerloop] = value  #as y value is before the x value
                SET innerLoop = innerLoop + 1
            END FOR
            SET outerLoop = outerLoop + 1

        END FOR

        FOR index = 0 to rows_count - 1 DO
            Me.addEdge(ME.matrix[index][0], ME.addEdge[index][1])
        END FOR 

        CLOSE CONNECTION
    END METHOD

    PUBLIC METHOD dijkstra(initial, final_destination)
        INITIALISE shortest_paths AS DICTIONARY 
        INITIALISE current_noodle AS STRING = initial
        INITIALISE visited AS DEFAULT SET #this is being done as it has a method to check if it contains things
        

        WHILE current_noodle NOT = final_destination DO
            ADD current_noodle TO visited SET
            INITIALISE destinations AS ARRAY INITIALLY ME.edges[current_noodle]

            FOR EACH next_noodle IN destinations DO
                IF next_noodle is not in shortest_paths
                    SET shortest_paths[next_noodle] = (current_noodle, 1) 
                ELSE
                    INITIALISE current_shortest_weight AS STRING
                    SET current_shortest_weight = shortest_paths[next_noodle][1]
                    IF current_shortest_weight > 1:
                        SET shortest_paths[next_noodle] = (current_noodle,1)
                    END IF
                END IF
            END FOR

            INITIALISE possible_noodle AS DEFAULT DICTIONARY
            FOR EACH noodle in shortest_paths
                IF noodle not in visited
                    SET possible_noodle[noodle] = shortest_paths[noodle]
                END IF
            END FOR

            IF possible_noodle is empty
                SEND message that there is no path TO DISPLAY
            END IF
            SET current_noodle = smallest value between possible_noodle and  
        END WHILE

    END METHOD
END CLASS


CLASS ui()
    INITIALISE PUBLIC STRING sectionName
    INITIALISE PRIVATE STRING contents
    INITIALISE PRIVATE STRING prompt
    INITIALISE PRIVATE DICTIONARY commands

    METHOD ui(section) #this is the constructor
        SET ME.sectionName = section
    END METHOD

    REGION getters
        METHOD setContents(contentsText)
            SET ME.contents = contentsText
        END METHOD

        METHOD setCommands(prompt, kwargs AS DICTIONARY) #kwargs is a dictionary of all parameters passed after the first
            ME.prompt = prompt
            FOR EACH key, value IN kwargs
                SET ME.commands[key.PREDEFINEDFUNCTION.lower()] = value
            END FOR
        END METHOD
    END REGION

    REGION setters
        METHOD showUi(acceptCommands AS BOOLEAN DEFAULT TRUE)
            CLEARSCREEN()
            INITIALISE userInput AS STRING
            SEND ME.contents TO DISPLAY
            IF acceptCommands = TRUE
                RECIEVE userInput FROM KEYBOARD
                IF userInput IS IN ME.commands
                    ME.commands[userInput.lower()]() #calls the function with the name at the key of the command dictionary
                ELSE 
                    SEND "Please select a valid option." TO DISPLAY
                    WAIT FOR KEY 
                    ME.showUI()
                END IF
            END IF
        END METHOD 
    END REGION
END CLASS
