https://www.sqa.org.uk/sqa/files_ccc/Reference-language-for-Computing-Science-Sep2016.pdf

CLASS noodlemap()
    PUBLIC METHOD noodlemap() #constructor method
        INITIALISE PRIVATE DICTIONARY edges 
        INITIALISE PRIVATE ARRAY OF ARRAY OF STRING matrix INITIALLY [[""]]
    END METHOD

    PRIVATE METHOD addEdge(origin_noodle, destination_noodle)
        APPEND destination_noodle TO edges[origin_noodle]
        
    END METHOD

    PRIVATE METHOD loadDatabase(tableName as string)
        
        INITIALISE domain AS STRING 
        connect to database "websites"
        
        domain = format tablename to domain form
        execute "SELECT OriginURL, Hyperlink FROM parameter" where parameter = domain and store result in 2d array called result
        

        INITIALISE cols_count AS INTEGER = 2
        INITIALISE rows_count AS INTEGER = len(result)
        
        
        ME.matrix = [["" for x = 0 to cols+count-1] for y = 0 to rows_count -1]

        INITIALISE innerLoop AS INTEGER = 0
        INITIALISE outerLoop as INTEGER = 0
        

        FOR EACH row IN result DO
            SET innerLoop = 0
            FOR each value in row DO
                SET ME.Matrix[outerloop][innerloop] = value  #as y value is before the x value
                SET innerLoop = innerLoop + 1
            END FOR
            SET outerLoop = outerLoop + 1

        END FOR

        FOR index = 0 to rows_count - 1 DO
            Me.addEdge(ME.matrix[index][0], ME.addEdge[index][1])
        END FOR 

        CLOSE CONNECTION
    END METHOD

    PUBLIC METHOD dijkstra(initial, final_destination)
        INITIALISE shortest_paths AS DICTIONARY 
        INITIALISE current_noodle AS STRING = initial
        INITIALISE visited AS DEFAULT SET #this is being done as it has a method to check if it contains things
        

        WHILE current_noodle NOT = final_destination DO
            ADD current_noodle TO visited SET
            INITIALISE destinations AS ARRAY INITIALLY ME.edges[current_noodle]

            FOR EACH next_noodles IN destinations DO
                IF next_noodles is not in shortest_paths
                    SET shortest_paths[next_noodles] = (current_noodle, 1) 
                ELSE
                    INITIALISE current_shortest_weight AS STRING
                    SET current_shortest_weight = shortest_paths[next_noodles][1]
                    IF current_shortest_weight > 1:
                        SET shortest_paths[next_noodles] = (current_noodle,1)
                    END IF
                END IF
            END FOR

            INITIALISE possible_noodle AS DEFAULT DICTIONARY
            FOR EACH noodle in shortest_paths
                IF noodle not in visited
                    SET possible_noodle[noodle] = shortest_paths[noodle]
                END IF
            END FOR

            IF possible_noodle is empty
                SEND message that there is no path TO DISPLAY
            END IF
            SET current_noodle = smallest value between possible_noodle and all the values at index one of all keys in the 
        END WHILE

        INITIALISE path AS ARRAY OF DICTIONARY
        WHILE current_noodle has values in it
            APPEND current_noodle TO path
            SET next_noodles = shortest_paths[current_noodle][0]
            SET current_noodle = next_noodles
        END WHILE

        SET path = reverse path
        RETURN path

    END METHOD

    PUBLIC METHOD returnMap(sort INITIALLY TRUE)
        INITIALISE unsorted_list[] AS ARRAY
        SET unsorted_list = ARRAY of keys of ME.edges
        
        IF sort = TRUE
            INITIALISE sorted_list AS DEFAULT DICTIONARY
            FOR EACH key IN ME.mergeSort(unsorted_list):
                SET sorted_list[key] = ME.edges[key]
            END FOR
            RETURN sorted_list
        ELSE:
            RETURN ME.edges
        END IF

    END METHOD

    PRIVATE METHOD mergeSort(array) 
        IF length of array <= 1
            RETURN array
        END IF

        INITIALISE left AS ARRAY OF STRING
        INITIALISE right AS ARRAY OF STRING
        INITIALISE counter AS INTEGER INITIALLY 0

        FOR EACH value IN array
            IF counter < (length of array) / 2 rounded down
                APPEND value TO left
            ELSE:
                APPEND value TO right
            END IF
            SET counter = counter + 1
        END FOR

        SET left = ME.mergeSort(left)
        SET right = ME.mergeSort(right)

        return self.Merge(left,right)
    END METHOD

    PRIVATE METHOD Merge(left, right)
        INITIALISE result AS ARRAY

        WHILE length of left NOT = 0 AND length of right NOT = 0
            FOR letter = 0 to (smallest between length of left[0] and length of right[0])
                IF left[0][letter] comes before right[0][letter]
                    pop left[0] and append it to result
                
                ELSE IF right[0][letter] comes before left[0][letter]
                    pop right[0] and append it to result
                
                ELSE IF length of left[0] < length of right[0] and (smallest between length of left[0] and length of right[0]) - 1
                    pop left[0] and append it to result
                
                ELSE IF length of left[0] > length of right[0] and (smallest between length of left[0] and length of right[0]) - 1
                    pop right[0] and append it to result

                END IF    
            END FOR
        END WHILE

        WHILE length of left NOT = 0
            pop left[0] and append it to result
        END WHILE

        WHILE length of right NOT = 0
            pop right[0] and append it to result
        END WHILE
    END METHOD

    PRIVATE METHOD insertSort(unsorted_list):
        FOR start_value = 1 to lenght of unsorted_list
            FOR current_value = start_value to 0 STEP -1
                FOR letter = 0 to smallest between length of unsorted_list[current_value] and length of unsorted_list[current_value-1]
                    IF unsorted_list[current_value][letter] comes before unsorted_list[current_noodle][letter]
                        SWAP unsorted_list[current_value] and unsorted_list[current_value-1]
                        BREAK FOR LOOP
                    ELSE IF length of unsorted_list[current_value] < length of unsorted_list[current_value - 1] and unsorted_list[current_value][letter] = unsorted_list[current_value][letter] AND letter = smallest value between length of unsorted_list[current_value] and length of unsorted_list[current_value]
                        SWAP unsorted_list[current_value] and unsorted_list[current_value-1]
                    END IF
                END FOR
            END FOR
        END FOR
        RETURN unsorted_list
    END METHOD
END CLASS


CLASS ui()
    INITIALISE PUBLIC STRING sectionName
    INITIALISE PRIVATE STRING contents
    INITIALISE PRIVATE STRING prompt
    INITIALISE PRIVATE DICTIONARY commands

    METHOD ui(section) #this is the constructor
        SET ME.sectionName = section
    END METHOD

    REGION setters
        METHOD setContents(contentsText)
            SET ME.contents = contentsText
        END METHOD

        METHOD setCommands(prompt, kwargs AS DICTIONARY) #kwargs is a dictionary of all parameters passed after the first
            ME.prompt = prompt
            FOR EACH key, value IN kwargs
                SET ME.commands[key.PREDEFINEDFUNCTION.lower()] = value
            END FOR
        END METHOD
    END REGION

    REGION getters
        METHOD showUi(acceptCommands AS BOOLEAN DEFAULT TRUE)
            CLEARSCREEN()
            INITIALISE userInput AS STRING
            SEND ME.contents TO DISPLAY
            IF acceptCommands = TRUE
                RECIEVE userInput FROM KEYBOARD
                IF userInput IS IN ME.commands
                    ME.commands[userInput.lower()]() #calls the function with the name at the key of the command dictionary
                ELSE 
                    SEND "Please select a valid option." TO DISPLAY
                    WAIT FOR KEY 
                    ME.showUI()
                END IF
            END IF
        END METHOD 


    END REGION
END CLASS


#on program start 
INSTANCIATE noodles as new noodlemap object
INSTANCIATE mainMenu as new ui("mainMenu") object
mainMenu.setContents('Welcome to PathFinder! To see help, type: help \n Options: \n pathfinder: Finds a path between two URLs \n ReturnMap: View all found links.')
mainMenu.setCommands(Pick option', pathfinder() procedure, returnMap() procedure, help() procedure, quit() procedure)
mainMenu.showUI()



checking if program is running from command line arguments or not:

IF length of arguments passed in command line > 1 
    IF mode argument is passed as "pathfinder"
        INITIALISE domain AS STRING
        SET domain = format startPage argument to domain form

        IF reindex argument = TRUE
            run the web scraper with parameters 
            TODO: this
        END IF
    END IF
END IF